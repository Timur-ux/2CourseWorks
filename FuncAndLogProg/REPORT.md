# Отчет по лабораторной работе №1

## Работа со списками и реляционным представлением данных

## по курсу "Логическое программирование"

### студент: Бучкин Т.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

**Ответ:** В императивных ЯП, в основном, используется массивы и структуры данных, основанные на оных. Преимущество массивов в произвольном доступе. Списки же имеют доступ последовательный. Это замедляет время доступа к элементу списка. Тем не менее, в силу ссылочной внутренней структуры списка, есть возможность создавать списки почти бесконечной длины(С ограничением в количество памяти), что особенно полезно при реализации разных корекурентных исчислений.

## Задание 1.1: Предикат обработки списка

`baseRemoveNLast(List, N, Result)` -- Удаляет поледние N элементов List и записывает результат в Result(Базовые предикаты).

`myRemoveNLast(List, N, Result)` -- Реализация того же предиката, посредством моих предикатов.

Примеры использования:

```prolog
?- baseRemoveNLast([a, b, c, d, e], 2, Result).
Result = [a, b, c] .

?- myRemoveNLast([a, b, c, d, e], 2, Result).
Result = [a, b, c] .
```

Реализация:

```prolog
baseRemoveNLast(List, N, Result) :- append(Result, Tail, List), len(Tail, N).

myRemoveNLast([Head | Tail], N, [Head]) :- myLen(Tail, N).
myRemoveNLast([Head | Tail], N, [Head | Result]) :- myRemoveNLast(Tail, N, Result). 
```

Опишите своими словами принцип работы предиката обработки списка.
**Ответ:** Базовая реализация используя append ищет все возможные хвосты списка. Если длина хвоста равна N, записывает голову(список, не элемент) в Result. Моя реализация итеративно проходит с головы до хвоста, пока хвост не станет длины N, собирая результат из головных элементов.

## Задание 1.2: Предикат обработки числового списка

`baseMean(List, Result)` -- Ищет среднее арифметическое списка (Базовые предикаты).
`myMean(List, Result)` -- Реализация того же предиката, посредством моих предикатов.

Реализация:

```prolog
mySum([], 0).
mySum([H|T], Result) :- mySum(T, Result1), Result is H + Result1.

baseMean(List, Result) :- mySum(List, S), len(List, N), Result is S / N.

myMean(List, Result) :- mySum(List, S), myLen(List, N), Result is S / N.
```

Опишите своими словами принцип работы предиката обработки списка.
**Ответ:** Предикаты находят сумму элементов списка и делят её на длину списка. Сумма не является базовым предикатом, так что она реализованна только один раз.

## Задание 2: Реляционное представление данных

Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.
**Ответ:** Реляционное представление является удобным способом хранения большого количества объектов в памяти в виде их отношений друг с другом. Моим является третье представление, и оно неудобно, что список предметов связан с человеком. Я считаю, что если все связи будут в виде rel(Group, Student, grade(Subject, Mark)), то делать запросы к такой безе будет легче.

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

### Задание 1.1

```prolog
getGroupsList(GroupList) :- setof(Group, getGroup(Group), GroupList).

getMeanForEachGroup(Group, GroupMean) :- getGroupsList(GList),
                                    member(Group, GList),
                                    findGroupMean(Group, GroupMean).
% По сути названия предикатов говорят сами за себя.
```

### Задание 1.2

```prolog
getSubjectBacklans(Subject, Backlans) :- subject(SubjectCode, Subject),
                    findall(Backlan, checkStudent(_, Backlan, SubjectCode), Backlans).

% Бакланы -- это студенты, которые не сдали хотя бы один предмет
```

### Задание 1.3

```prolog
getGroupBacklansQuantity(Group, BacklansQuantity) :-
                    getGroupsList(GList),
                    member(Group, GList),
                    findall(Backlan, checkStudent(Group, Backlan, _), BacklansList1),
                    setof(Backlan, member(Backlan, BacklansList1), BacklansList),
                    len(BacklansList, BacklansQuantity).

% Бакланы -- это студенты, которые не сдали хотя бы один предмет
```

## Выводы

В результате этой работы я узнал больше о переборных решениях тривиальных задач. Если не рассматривать эффективность данного языка, а смотреть только на выразительность, то Пролог, несомненно, очень интересный язык. Я вижу определённые сходства Пролога с процедурными языками програмирования, но только с точки зрения абстракций. В том же Си конструкция proc(arg1, arg2, Result) является довольно обычной.
